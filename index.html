<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>hurl</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        background-color: #1e1e1e;
      }

      .top-container {
        height: 42px;
        display: flex;
        flex-direction: row;
        border-bottom: 1px solid #2c2c2c;
      }

      .toolbar {
        flex: 1;
        background-color: transparent;
        display: flex;
        align-items: center;
        gap: 0;
      }

      .sidebar-top {
        width: 400px;
        background-color: #2d2d30;
        border-left: 1px solid #2c2c2c;
        display: flex;
        align-items: center;
        padding: 0 12px;
        font-size: 12px;
        color: #cccccc;
      }

      .main-container {
        flex: 1;
        display: flex;
        flex-direction: row;
      }

      .left-panel {
        display: flex;
        flex-direction: column;
        flex: 1;
      }

      .sidebar {
        width: 400px;
        background-color: #252526;
        border-left: 1px solid #2c2c2c;
        display: flex;
        flex-direction: column;
      }

      .sidebar-content {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      #sidebarEditor {
        flex: 1;
        border: none;
        background-color: #1e1e1e;
        color: #d4d4d4;
        font-family: "SF Mono", "Monaco", "Inconsolata", "Fira Code", monospace;
        font-size: 13px;
        padding: 12px;
        resize: none;
        outline: none;
        line-height: 1.4;
      }

      .toolbar {
        height: 42px;
        background-color: transparent;
        border-bottom: 1px solid #2c2c2c;
        display: flex;
        align-items: center;
        gap: 0;
      }

      #commandLine {
        flex: 1;
        height: 40px;
        padding: 0 12px;
        border: 1px solid #343434;
        border-right: none;
        border-radius: 0;
        font-size: 14px;
        outline: none;
        background-color: #2c2c2c;
        color: #ffffff;
        margin: 0;
      }

      #commandLine:focus {
        border-color: #343434;
        box-shadow: none;
      }



      #textArea {
        flex: 1;
        border: none;
        background-color: #1e1e1e;
        color: #ffffff;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        font-size: 14px;
        padding: 12px;
        resize: none;
        outline: none;
      }
    </style>
  </head>
  <body>
    <div class="top-container">
      <div class="toolbar">
        <input
          type="text"
          id="commandLine"
          placeholder="(⌘+1) 커맨드를 입력하세요"
          value=""
        />
      </div>
      <div class="sidebar-top">
        <span id="sidebarTitle">파일이 선택되지 않음</span>
      </div>
    </div>

    <div class="main-container">
      <div class="left-panel">
        <textarea
          id="textArea"
          placeholder="(⌘+3) 커맨드 실행 결과가 여기에 표시됩니다"
        ></textarea>
      </div>
      
      <div class="sidebar">
        <div class="sidebar-content">
          <textarea
            id="sidebarEditor"
            placeholder="(⌘+2) ⌘+R 을 눌러 hurl 파일을 로드하세요"
          ></textarea>
        </div>
      </div>
    </div>

    <script>
      const commandLine = document.getElementById("commandLine");
      const textArea = document.getElementById("textArea");
      const sidebarEditor = document.getElementById("sidebarEditor");
      const sidebarTitle = document.getElementById("sidebarTitle");
      
      // 현재 편집 중인 파일 정보
      let currentFilePath = null;
      
      // 커맨드 히스토리 관리
      let commandHistory = [];
      let historyIndex = -1;
      let sessionHistory = []; // 현재 세션에서 추가된 커맨드들
      


      // JSON인지 확인하고 beautify하는 함수
      function formatOutput(output) {
        try {
          // 문자열을 trim하고 JSON 파싱 시도
          const trimmedOutput = output.trim();
          
          // JSON인지 확인 ({}나 []로 시작하는지 체크)
          if ((trimmedOutput.startsWith('{') && trimmedOutput.endsWith('}')) ||
              (trimmedOutput.startsWith('[') && trimmedOutput.endsWith(']'))) {
            
            const jsonObj = JSON.parse(trimmedOutput);
            return JSON.stringify(jsonObj, null, 2); // 2칸 들여쓰기로 beautify
          }
        } catch (e) {
          // JSON 파싱 실패시 원본 반환
        }
        
        // JSON이 아니거나 파싱 실패시 원본 반환
        return output;
      }

      // 히스토리에 커맨드 추가 (중복 방지)
      function addToHistory(command) {
        // 세션 히스토리에 추가 (중복 제거 없이)
        sessionHistory.push(command);
        
        // 메모리 히스토리에서 중복 제거
        const existingIndex = commandHistory.indexOf(command);
        if (existingIndex !== -1) {
          commandHistory.splice(existingIndex, 1);
        }
        
        // 새로운 커맨드를 배열 끝에 추가 (최신이 마지막)
        commandHistory.push(command);
        
        // 히스토리 인덱스 초기화
        historyIndex = -1;
      }

      // 프로그램 시작 시 히스토리 로드
      async function loadHistory() {
        try {
          const history = await window.electronAPI.loadHistory();
          commandHistory = history;
          console.log('히스토리 로드됨:', history.length, '개 항목');
        } catch (error) {
          console.error('히스토리 로드 오류:', error);
        }
      }

      // 프로그램 종료 시 세션 히스토리 저장
      async function saveSessionHistory() {
        try {
          if (sessionHistory.length > 0) {
            await window.electronAPI.saveHistory(sessionHistory);
            console.log('세션 히스토리 저장됨:', sessionHistory.length, '개 항목');
          }
        } catch (error) {
          console.error('히스토리 저장 오류:', error);
        }
      }

      // hurl 파일 경로 추출 함수
      function extractHurlFilePath(command) {
        // "hurl" 로 시작하는 커맨드에서 .hurl 파일 경로 추출
        const parts = command.trim().split(/\s+/);
        if (parts[0].toLowerCase() === 'hurl') {
          for (let i = 1; i < parts.length; i++) {
            if (parts[i].endsWith('.hurl')) {
              return parts[i];
            }
          }
        }
        return null;
      }

      // 파일 로드 함수
      async function loadHurlFile() {
        const command = commandLine.value.trim();
        const filePath = extractHurlFilePath(command);
        
        if (!filePath) {
          sidebarTitle.textContent = "hurl 파일 경로를 찾을 수 없습니다";
          sidebarEditor.value = "";
          currentFilePath = null;
          return;
        }

        try {
          const result = await window.electronAPI.readFile(filePath);
          if (result.success) {
            sidebarEditor.value = result.content;
            sidebarTitle.textContent = filePath.split('/').pop();
            currentFilePath = filePath;
            sidebarEditor.focus();
          } else {
            sidebarTitle.textContent = "파일 로드 실패";
            sidebarEditor.value = `오류: ${result.error}`;
            currentFilePath = null;
          }
        } catch (error) {
          sidebarTitle.textContent = "파일 로드 오류";
          sidebarEditor.value = `오류: ${error.message}`;
          currentFilePath = null;
        }
      }

      // 파일 저장 함수
      async function saveHurlFile() {
        if (!currentFilePath) {
          // 텍스트 영역에 메시지 표시
          const timestamp = new Date().toLocaleTimeString();
          const newContent = `[${timestamp}] 저장할 파일이 선택되지 않았습니다.\n\n`;
          textArea.value = newContent + textArea.value;
          return;
        }

        try {
          const result = await window.electronAPI.writeFile(currentFilePath, sidebarEditor.value);
          if (result.success) {
            // 텍스트 영역에 성공 메시지 표시
            const timestamp = new Date().toLocaleTimeString();
            const newContent = `[${timestamp}] 파일 저장됨: ${currentFilePath}\n\n`;
            textArea.value = newContent + textArea.value;
          } else {
            // 텍스트 영역에 오류 메시지 표시
            const timestamp = new Date().toLocaleTimeString();
            const newContent = `[${timestamp}] 파일 저장 실패: ${result.error}\n\n`;
            textArea.value = newContent + textArea.value;
          }
        } catch (error) {
          // 텍스트 영역에 오류 메시지 표시
          const timestamp = new Date().toLocaleTimeString();
          const newContent = `[${timestamp}] 파일 저장 오류: ${error.message}\n\n`;
          textArea.value = newContent + textArea.value;
        }
      }

      // 히스토리 클리어 함수
      async function clearHistory() {
        try {
          // 메모리 히스토리 초기화
          commandHistory = [];
          sessionHistory = [];
          historyIndex = -1;
          
          // 로컬 파일 히스토리 클리어
          await window.electronAPI.clearHistory();
          
          console.log('히스토리가 모두 초기화되었습니다.');
          return true;
        } catch (error) {
          console.error('히스토리 클리어 오류:', error);
          return false;
        }
      }

      async function executeCommand() {
        let command = commandLine.value.trim();

        // 커맨드가 비어있으면 리턴
        if (!command) return;

        // "clear" 커맨드인지 확인
        if (command.toLowerCase() === "clear") {
          const cleared = await clearHistory();
          if (cleared) {
            // 텍스트 영역도 클리어
            textArea.value = "";
            // 성공 메시지 표시
            const timestamp = new Date().toLocaleTimeString();
            const newContent = `[${timestamp}] $ ${command}\n히스토리가 모두 초기화되었습니다.\n\n`;
            textArea.value = newContent + textArea.value;
          } else {
            // 에러 메시지 표시
            const timestamp = new Date().toLocaleTimeString();
            const newContent = `[${timestamp}] $ ${command}\n히스토리 초기화 중 오류가 발생했습니다.\n\n`;
            textArea.value = newContent + textArea.value;
          }
          
          // 커맨드 라인 초기화
          commandLine.value = "";
          return;
        }

        // 히스토리에 추가
        addToHistory(command);

        try {
          // Desktop Commander를 통해 커맨드 실행
          const response = await window.electronAPI.executeCommand(command);
          
          // JSON 형식인지 확인하고 beautify
          const formattedResponse = formatOutput(response);
          
          // 기존 텍스트 위에 새로운 결과 추가 (최신이 위로)
          const timestamp = new Date().toLocaleTimeString();
          const newContent = `[${timestamp}] $ ${command}\n${formattedResponse}\n\n`;
          textArea.value = newContent + textArea.value;
        } catch (error) {
          // 에러가 발생한 경우
          const timestamp = new Date().toLocaleTimeString();
          const newContent = `[${timestamp}] $ ${command}\nError: ${error.message}\n\n`;
          textArea.value = newContent + textArea.value;
        }

        // 커맨드 라인 초기화
        commandLine.value = "";
      }



      // 커맨드라인에서 키 이벤트 (엔터키, 화살표키)
      commandLine.addEventListener("keydown", function (e) {
        if (e.key === "Enter") {
          executeCommand();
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          // 히스토리에서 이전 커맨드 가져오기 (최신부터)
          if (commandHistory.length > 0) {
            if (historyIndex === -1) {
              historyIndex = commandHistory.length - 1;
            } else if (historyIndex > 0) {
              historyIndex--;
            }
            commandLine.value = commandHistory[historyIndex];
          }
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          // 히스토리에서 다음 커맨드 가져오기
          if (commandHistory.length > 0 && historyIndex !== -1) {
            if (historyIndex < commandHistory.length - 1) {
              historyIndex++;
              commandLine.value = commandHistory[historyIndex];
            } else {
              historyIndex = -1;
              commandLine.value = "";
            }
          }
        }
      });

      // 텍스트 영역에 붙여넣기 이벤트 (JSON 자동 beautify)
      textArea.addEventListener("paste", function (e) {
        e.preventDefault(); // 기본 붙여넣기 동작 방지
        
        // 클립보드에서 텍스트 가져오기
        const clipboardData = e.clipboardData || window.clipboardData;
        const pastedText = clipboardData.getData('text');
        
        // JSON 형식인지 확인하고 beautify
        const formattedText = formatOutput(pastedText);
        
        // 현재 커서 위치에 삽입
        const startPos = textArea.selectionStart;
        const endPos = textArea.selectionEnd;
        const currentText = textArea.value;
        
        textArea.value = currentText.substring(0, startPos) + formattedText + currentText.substring(endPos);
        
        // 커서 위치 조정
        const newCursorPos = startPos + formattedText.length;
        textArea.setSelectionRange(newCursorPos, newCursorPos);
      });

      // 페이지 로드 시 히스토리 로드
      window.addEventListener('DOMContentLoaded', function() {
        loadHistory();
        // 커맨드창에 포커스
        commandLine.focus();
      });

      // 페이지 종료 시 세션 히스토리 저장
      window.addEventListener('beforeunload', function() {
        saveSessionHistory();
      });

      // 전역 단축키 처리
      document.addEventListener('keydown', function(e) {
        // Command + R: hurl 파일 로드
        if ((e.metaKey || e.ctrlKey) && e.key === 'r') {
          e.preventDefault();
          loadHurlFile();
          return;
        }
        
        // Command + S: 파일 저장
        if ((e.metaKey || e.ctrlKey) && e.key === 's') {
          e.preventDefault();
          saveHurlFile();
          return;
        }
        
        // Command + 1: 커맨드창에 포커스
        if ((e.metaKey || e.ctrlKey) && e.key === '1') {
          e.preventDefault();
          commandLine.focus();
          return;
        }
        
        // Command + 2: 사이드바에 포커스
        if ((e.metaKey || e.ctrlKey) && e.key === '2') {
          e.preventDefault();
          sidebarEditor.focus();
          return;
        }
        
        // Command + 3: 결과창에 포커스
        if ((e.metaKey || e.ctrlKey) && e.key === '3') {
          e.preventDefault();
          textArea.focus();
          return;
        }
      });












    </script>
  </body>
</html>
