<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>hurl</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        background-color: #1e1e1e;
      }

      .toolbar {
        height: 42px;
        background-color: transparent;
        border-bottom: 1px solid #2c2c2c;
        display: flex;
        align-items: center;
        gap: 0;
      }

      #commandLine {
        flex: 1;
        height: 40px;
        padding: 0 12px;
        border: 1px solid #343434;
        border-right: none;
        border-radius: 0;
        font-size: 14px;
        outline: none;
        background-color: #2c2c2c;
        color: #ffffff;
        margin: 0;
      }

      #commandLine:focus {
        border-color: #343434;
        box-shadow: none;
      }



      #textArea {
        flex: 1;
        border: none;
        background-color: #1e1e1e;
        color: #ffffff;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        font-size: 14px;
        padding: 12px;
        resize: none;
        outline: none;
      }
    </style>
  </head>
  <body>
    <div class="toolbar">
      <input
        type="text"
        id="commandLine"
        placeholder="커맨드를 입력하세요"
        value=""
      />

    </div>

    <textarea
      id="textArea"
      placeholder="커맨드 실행 결과가 여기에 표시됩니다"
    ></textarea>

    <script>
      const commandLine = document.getElementById("commandLine");
      const textArea = document.getElementById("textArea");
      
      // 커맨드 히스토리 관리
      let commandHistory = [];
      let historyIndex = -1;
      let sessionHistory = []; // 현재 세션에서 추가된 커맨드들
      


      // JSON인지 확인하고 beautify하는 함수
      function formatOutput(output) {
        try {
          // 문자열을 trim하고 JSON 파싱 시도
          const trimmedOutput = output.trim();
          
          // JSON인지 확인 ({}나 []로 시작하는지 체크)
          if ((trimmedOutput.startsWith('{') && trimmedOutput.endsWith('}')) ||
              (trimmedOutput.startsWith('[') && trimmedOutput.endsWith(']'))) {
            
            const jsonObj = JSON.parse(trimmedOutput);
            return JSON.stringify(jsonObj, null, 2); // 2칸 들여쓰기로 beautify
          }
        } catch (e) {
          // JSON 파싱 실패시 원본 반환
        }
        
        // JSON이 아니거나 파싱 실패시 원본 반환
        return output;
      }

      // 히스토리에 커맨드 추가 (중복 방지)
      function addToHistory(command) {
        // 세션 히스토리에 추가 (중복 제거 없이)
        sessionHistory.push(command);
        
        // 메모리 히스토리에서 중복 제거
        const existingIndex = commandHistory.indexOf(command);
        if (existingIndex !== -1) {
          commandHistory.splice(existingIndex, 1);
        }
        
        // 새로운 커맨드를 배열 끝에 추가 (최신이 마지막)
        commandHistory.push(command);
        
        // 히스토리 인덱스 초기화
        historyIndex = -1;
      }

      // 프로그램 시작 시 히스토리 로드
      async function loadHistory() {
        try {
          const history = await window.electronAPI.loadHistory();
          commandHistory = history;
          console.log('히스토리 로드됨:', history.length, '개 항목');
        } catch (error) {
          console.error('히스토리 로드 오류:', error);
        }
      }

      // 프로그램 종료 시 세션 히스토리 저장
      async function saveSessionHistory() {
        try {
          if (sessionHistory.length > 0) {
            await window.electronAPI.saveHistory(sessionHistory);
            console.log('세션 히스토리 저장됨:', sessionHistory.length, '개 항목');
          }
        } catch (error) {
          console.error('히스토리 저장 오류:', error);
        }
      }

      // 히스토리 클리어 함수
      async function clearHistory() {
        try {
          // 메모리 히스토리 초기화
          commandHistory = [];
          sessionHistory = [];
          historyIndex = -1;
          
          // 로컬 파일 히스토리 클리어
          await window.electronAPI.clearHistory();
          
          console.log('히스토리가 모두 초기화되었습니다.');
          return true;
        } catch (error) {
          console.error('히스토리 클리어 오류:', error);
          return false;
        }
      }

      async function executeCommand() {
        let command = commandLine.value.trim();

        // 커맨드가 비어있으면 리턴
        if (!command) return;

        // "clear" 커맨드인지 확인
        if (command.toLowerCase() === "clear") {
          const cleared = await clearHistory();
          if (cleared) {
            // 텍스트 영역도 클리어
            textArea.value = "";
            // 성공 메시지 표시
            const timestamp = new Date().toLocaleTimeString();
            const newContent = `[${timestamp}] $ ${command}\n히스토리가 모두 초기화되었습니다.\n\n`;
            textArea.value = newContent + textArea.value;
          } else {
            // 에러 메시지 표시
            const timestamp = new Date().toLocaleTimeString();
            const newContent = `[${timestamp}] $ ${command}\n히스토리 초기화 중 오류가 발생했습니다.\n\n`;
            textArea.value = newContent + textArea.value;
          }
          
          // 커맨드 라인 초기화
          commandLine.value = "";
          return;
        }

        // 히스토리에 추가
        addToHistory(command);

        try {
          // Desktop Commander를 통해 커맨드 실행
          const response = await window.electronAPI.executeCommand(command);
          
          // JSON 형식인지 확인하고 beautify
          const formattedResponse = formatOutput(response);
          
          // 기존 텍스트 위에 새로운 결과 추가 (최신이 위로)
          const timestamp = new Date().toLocaleTimeString();
          const newContent = `[${timestamp}] $ ${command}\n${formattedResponse}\n\n`;
          textArea.value = newContent + textArea.value;
        } catch (error) {
          // 에러가 발생한 경우
          const timestamp = new Date().toLocaleTimeString();
          const newContent = `[${timestamp}] $ ${command}\nError: ${error.message}\n\n`;
          textArea.value = newContent + textArea.value;
        }

        // 커맨드 라인 초기화
        commandLine.value = "";
      }



      // 커맨드라인에서 키 이벤트 (엔터키, 화살표키)
      commandLine.addEventListener("keydown", function (e) {
        if (e.key === "Enter") {
          executeCommand();
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          // 히스토리에서 이전 커맨드 가져오기 (최신부터)
          if (commandHistory.length > 0) {
            if (historyIndex === -1) {
              historyIndex = commandHistory.length - 1;
            } else if (historyIndex > 0) {
              historyIndex--;
            }
            commandLine.value = commandHistory[historyIndex];
          }
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          // 히스토리에서 다음 커맨드 가져오기
          if (commandHistory.length > 0 && historyIndex !== -1) {
            if (historyIndex < commandHistory.length - 1) {
              historyIndex++;
              commandLine.value = commandHistory[historyIndex];
            } else {
              historyIndex = -1;
              commandLine.value = "";
            }
          }
        }
      });

      // 텍스트 영역에 붙여넣기 이벤트 (JSON 자동 beautify)
      textArea.addEventListener("paste", function (e) {
        e.preventDefault(); // 기본 붙여넣기 동작 방지
        
        // 클립보드에서 텍스트 가져오기
        const clipboardData = e.clipboardData || window.clipboardData;
        const pastedText = clipboardData.getData('text');
        
        // JSON 형식인지 확인하고 beautify
        const formattedText = formatOutput(pastedText);
        
        // 현재 커서 위치에 삽입
        const startPos = textArea.selectionStart;
        const endPos = textArea.selectionEnd;
        const currentText = textArea.value;
        
        textArea.value = currentText.substring(0, startPos) + formattedText + currentText.substring(endPos);
        
        // 커서 위치 조정
        const newCursorPos = startPos + formattedText.length;
        textArea.setSelectionRange(newCursorPos, newCursorPos);
      });

      // 페이지 로드 시 히스토리 로드
      window.addEventListener('DOMContentLoaded', function() {
        loadHistory();
      });

      // 페이지 종료 시 세션 히스토리 저장
      window.addEventListener('beforeunload', function() {
        saveSessionHistory();
      });












    </script>
  </body>
</html>
